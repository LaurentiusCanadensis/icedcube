===== src/ui/bottom.rs =====
use iced::{
    Alignment, Element, Length,
    widget::{row, column, text, text_input, button},
};
use crate::app::Msg;

/// Bottom section: seed + Apply/Scramble/Reset + move buttons.
///
/// - `seed`: current seed string
/// - `on_seed_change`: message maker for seed text change
/// - `on_apply`: Apply current seed/alg
/// - `on_scramble`: randomize + fill seed field + apply
/// - `on_reset`: full reset button
/// - `on_move`: move button pressed ("U", "U'", …)
pub fn bottom_section<'a, FMove>(
    seed: &str,
    on_seed_change: fn(String) -> Msg,
    on_apply: Msg,
    on_scramble: Msg,
    on_reset: Msg,
    on_move: FMove,
) -> Element<'a, Msg>
where
    FMove: Fn(&'static str) -> Msg + Copy + 'a,
{
    let seed_row = row![
        text("Seed"),
        text_input("Enter seed (e.g., 12345)", seed)
            .on_input(on_seed_change)
            .width(Length::Fixed(220.0)),
        button("Apply").on_press(on_apply),
        button("Scramble").on_press(on_scramble),
        button("Reset").on_press(on_reset),
    ]
        .spacing(8)
        .align_items(Alignment::Center)
        .width(Length::Fill);

    let moves_top = row![
        mv("U", on_move),  mv("U'", on_move), mv("U2", on_move),
        mv("R", on_move),  mv("R'", on_move), mv("R2", on_move),
        mv("F", on_move),  mv("F'", on_move), mv("F2", on_move),
    ]
        .spacing(8)
        .align_items(Alignment::Center);

    let moves_bot = row![
        mv("D", on_move),  mv("D'", on_move), mv("D2", on_move),
        mv("L", on_move),  mv("L'", on_move), mv("L2", on_move),
        mv("B", on_move),  mv("B'", on_move), mv("B2", on_move),
    ]
        .spacing(8)
        .align_items(Alignment::Center);

    column![seed_row, text("Moves"), moves_top, moves_bot]
        .spacing(10)
        .width(Length::Fill)
        .into()
}

#[inline]
fn mv<'a, F>(label: &'static str, on_move: F) -> Element<'a, Msg>
where
    F: Fn(&'static str) -> Msg + Copy + 'a,
{
    button(label).on_press(on_move(label)).into()
}
===== src/ui/moves.rs =====
use iced::{
    Element, Length,
    widget::{button, row, column, text, scrollable},
};
use crate::app::Msg;

fn btn(tok: &'static str) -> iced::widget::Button<'static, Msg> {
    button(text(tok).size(14))      // smaller label
        .padding([4, 8])            // tighter padding
        .on_press(Msg::Move(tok.to_string()))
        .width(Length::Shrink)
}

/// Two compact horizontal scrollers so they don’t explode at small widths.
pub fn build_moves_scroller() -> Element<'static, Msg> {
    let row1 = ["U", "U'", "U2", "R", "R'", "R2", "F", "F'", "F2"]
        .into_iter().map(btn).fold(row![], |r, b| r.push(b))
        .spacing(6);

    let row2 = ["D", "D'", "D2", "L", "L'", "L2", "B", "B'", "B2"]
        .into_iter().map(btn).fold(row![], |r, b| r.push(b))
        .spacing(6);

    let props = scrollable::Properties::default();

    let sc1 = scrollable(row1)
        .direction(scrollable::Direction::Horizontal(props))
        .height(Length::Shrink);

    let sc2 = scrollable(row2)
        .direction(scrollable::Direction::Horizontal(props))
        .height(Length::Shrink);

    column![text("Moves").size(16), sc1, sc2]
        .spacing(6)
        .into()
}
===== src/ui/mod.rs =====
pub mod moves;
pub mod panels;
pub(crate) mod bottom;

pub use panels::{build_algorithm_panel, build_angle_block, build_presets_row, build_seed_panel};
===== src/ui/panels.rs =====
use iced::{
    Alignment, Element, Length,
    widget::{row, column, text, text_input, button, checkbox, slider},
};
use crate::app::Msg;

pub fn build_angle_block<
    Fz: Fn(f32) -> Msg + 'static + Copy,
    Fx: Fn(f32) -> Msg + 'static + Copy,
    Fy: Fn(f32) -> Msg + 'static + Copy,
>(
    title: &str,
    rz: f32, rx: f32, ry: f32,
    on_rz: Fz, on_rx: Fx, on_ry: Fy,
) -> Element<'static, Msg> {
    column![
        text(title),
        row![ text("Rz"), slider(0.0..=360.0, rz, on_rz).step(1.0), text(format!("{:.0}°", rz)) ].spacing(8),
        row![ text("Rx"), slider(0.0..=360.0, rx, on_rx).step(1.0), text(format!("{:.0}°", rx)) ].spacing(8),
        row![ text("Ry"), slider(0.0..=360.0, ry, on_ry).step(1.0), text(format!("{:.0}°", ry)) ].spacing(8),
    ]
        .spacing(6)
        .into()
}

pub fn build_presets_row(snap90: bool) -> Element<'static, Msg> {
    row![
        button("Preset Left U/F/R").on_press(Msg::PresetLeft),
        button("Preset Right D/L/B").on_press(Msg::PresetRight),
        button("Reset Cameras").on_press(Msg::ResetCameras),
        checkbox("Snap 90°", snap90).on_toggle(Msg::ToggleSnap90),
    ]
        .spacing(12)
        .align_items(Alignment::Center)
        .into()
}

pub fn build_seed_panel(seed: &str) -> Element<'static, Msg> {
    row![
        text("Seed"),
        text_input("Enter seed (e.g., 12345)", seed)
            .on_input(Msg::SeedChanged)
            .width(Length::Fixed(220.0)),
        button("Apply").on_press(Msg::ApplySeed),
        button("Scramble").on_press(Msg::Scramble),
        button("Reset").on_press(Msg::Reset),
    ]
        .spacing(8)
        .align_items(Alignment::Center)
        .into()
}

pub fn build_algorithm_panel(alg: &str) -> Element<'static, Msg> {
    // If/when you add a dedicated AlgChanged, swap the .on_input handler.
    row![
        text_input("Algorithm (e.g., R U R' U')", alg)
            .on_input(Msg::SeedChanged) // placeholder to keep compiling
            .width(Length::Fill),
    ]
        .spacing(8)
        .align_items(Alignment::Center)
        .into()
}
===== src/app/logic.rs =====

===== src/app/support.rs =====
// src/app/support.rs

use crate::cube::Cube;

/// Clamp/snap angle
pub fn set_deg(v: f32, snap90: bool) -> f32 {
    let mut d = if snap90 {
        let r = (v / 90.0).round() * 90.0;
        if r < 0.0 { r + 360.0 } else { r % 360.0 }
    } else {
        v % 360.0
    };
    if d < 0.0 { d += 360.0; }
    d
}

/// Apply a space-separated algorithm to the cube, e.g. "R U R' U'"
pub fn apply_alg(cube: &mut Cube, alg: &str) -> Result<(), String> {
    for tok in alg.split_whitespace() {
        apply_token(cube, tok)?;
    }
    Ok(())
}

/// Apply a single token like "R", "R'", "R2"
pub fn apply_token(cube: &mut Cube, tok: &str) -> Result<(), String> {
    match tok {
        "U"  => { cube.mv_u(); Ok(()) }
        "U'" => { cube.mv_u_prime(); Ok(()) }
        "U2" => { cube.mv_u2(); Ok(()) }

        "D"  => { cube.mv_d(); Ok(()) }
        "D'" => { cube.mv_d_prime(); Ok(()) }
        "D2" => { cube.mv_d2(); Ok(()) }

        "R"  => { cube.mv_r(); Ok(()) }
        "R'" => { cube.mv_r_prime(); Ok(()) }
        "R2" => { cube.mv_r2(); Ok(()) }

        "L"  => { cube.mv_l(); Ok(()) }
        "L'" => { cube.mv_l_prime(); Ok(()) }
        "L2" => { cube.mv_l2(); Ok(()) }

        "F"  => { cube.mv_f(); Ok(()) }
        "F'" => { cube.mv_f_prime(); Ok(()) }
        "F2" => { cube.mv_f2(); Ok(()) }

        "B"  => { cube.mv_b(); Ok(()) }
        "B'" => { cube.mv_b_prime(); Ok(()) }
        "B2" => { cube.mv_b2(); Ok(()) }

        other => Err(format!("Unknown move: {other}")),
    }
}
===== src/app/update.rs =====
use iced::Command;
use rand::{thread_rng, RngCore};

use crate::cube::Cube;
use crate::logic::scramble::scramble_with_seed;

use super::{App, Msg};
use super::support::{set_deg, apply_alg, apply_token};

const SCRAMBLE_LEN: usize = 15;

// --------- helpers ----------------------------------------------------------

#[inline]
fn wrap_deg(mut v: f32) -> f32 {
    v = v % 360.0;
    if v < 0.0 { v += 360.0; }
    v
}

// When the link is ON, compute the opposite-facing right view from left.
// (Matches D/L/B “opposite” feel — 180° about X.)
fn sync_right_from_left(app: &mut App) {
    if app.link_opposite {
        app.params.right.rz = app.params.left.rz;
        app.params.right.ry = app.params.left.ry;
        app.params.right.rx = wrap_deg(app.params.left.rx + 180.0);
    }
}

// Apply a text algorithm to the cube; update status accordingly.
fn try_apply_alg(app: &mut App, alg: &str) {
    if alg.trim().is_empty() {
        app.status = "Nothing to apply. Enter an algorithm or a seed.".into();
        return;
    }
    match apply_alg(&mut app.cube, alg) {
        Ok(()) => app.status = "Applied algorithm.".into(),
        Err(e) => app.status = format!("Algorithm error: {e}"),
    }
}

// Produce a deterministic scramble from a seed and apply it.
// Also stores the text sequence into alg_input.
fn apply_seeded_scramble(app: &mut App, seed: u64) {
    let seq = scramble_with_seed(SCRAMBLE_LEN, seed);
    app.cube = Cube::default();
    match apply_alg(&mut app.cube, &seq) {
        Ok(()) => {
            app.alg_input = seq.clone();
            app.status = format!("Applied seed = {seed}: {seq}");
        }
        Err(e) => app.status = format!("Seeded scramble error: {e}"),
    }
}

// --------- main update ------------------------------------------------------

pub fn update(app: &mut App, msg: Msg) -> Command<Msg> {
    match msg {
        // ----- cameras (left, drives right when linked) ----------
        Msg::LeftRzChanged(v) => { app.params.left.rz = set_deg(v, app.snap90); sync_right_from_left(app); }
        Msg::LeftRxChanged(v) => { app.params.left.rx = set_deg(v, app.snap90); sync_right_from_left(app); }
        Msg::LeftRyChanged(v) => { app.params.left.ry = set_deg(v, app.snap90); sync_right_from_left(app); }

        // Right edits break the link (one-way sync to avoid ping-pong loops)
        Msg::RightRzChanged(v) => { app.link_opposite = false; app.params.right.rz = set_deg(v, app.snap90); }
        Msg::RightRxChanged(v) => { app.link_opposite = false; app.params.right.rx = set_deg(v, app.snap90); }
        Msg::RightRyChanged(v) => { app.link_opposite = false; app.params.right.ry = set_deg(v, app.snap90); }

        Msg::SizeChanged(v) => { app.params.size = v; }

        // Presets / reset cameras
        Msg::PresetLeft => {
            // Left (cube 1) at 0,0,0
            app.params.left  = super::ViewUI { rz: 0.0,  rx: 0.0,   ry: 0.0 };
            // If linked, drive right from left
            sync_right_from_left(app);
        }
        Msg::PresetRight => {
            // Right (cube 2) at 90,180,0 (your requested pose)
            app.params.right = super::ViewUI { rz: 90.0, rx: 180.0, ry: 0.0 };
            // Manual edit → unlink (so this doesn't bounce back)
            app.link_opposite = false;
        }
        Msg::ResetCameras => {
            app.params.left  = super::ViewUI { rz: 0.0,  rx: 0.0,   ry: 0.0 };
            app.params.right = super::ViewUI { rz: 90.0, rx: 180.0, ry: 0.0 };
            // Keep current link flag as-is
            if app.link_opposite { sync_right_from_left(app); }
        }

        // Snap 90°
        Msg::ToggleSnap90(on) => { app.snap90 = on; }

        // Opposite-right link toggle
        Msg::ToggleOpposite(on) => {
            app.link_opposite = on;
            if on { sync_right_from_left(app); }
        }

        // ----- algorithm / seed actions ------------------------------------

        Msg::AlgChanged(s) => { app.alg_input = s; }

        Msg::ApplyAlg => {
            // Own the text so we can mutably borrow `app` below
            let alg_text = app.alg_input.trim().to_owned();

            if !alg_text.is_empty() {
                // Now safe: `alg_text` doesn't borrow from `app`
                try_apply_alg(app, &alg_text);
            } else if let Ok(seed) = app.seed_input.trim().parse::<u64>() {
                apply_seeded_scramble(app, seed);
            } else {
                app.status = "Nothing to apply. Enter an algorithm or a seed.".into();
            }
        }

        Msg::ResetCube => {
            app.cube = Cube::default();
            app.status = "Cube reset.".into();
        }

        Msg::SeedChanged(s) => { app.seed_input = s; }

        Msg::ApplySeed => {
            if let Ok(seed) = app.seed_input.trim().parse::<u64>() {
                apply_seeded_scramble(app, seed);
            } else {
                app.status = "No valid seed entered — nothing applied.".into();
            }
        }

        Msg::Scramble => {
            // Pick a brand-new random seed and apply a deterministic scramble.
            let mut rng = thread_rng();
            let seed = rng.next_u64();                // no recursion, no gen() ambiguity
            app.seed_input = seed.to_string();
            apply_seeded_scramble(app, seed);
        }

        // “Reset” for the seed/algorithm inputs (kept for convenience)
        Msg::Reset => {
            app.alg_input.clear();
            app.seed_input.clear();
            app.status.clear();
        }

        Msg::SeedClear => { app.seed_input.clear(); }

        // ----- single move buttons -----------------------------------------
        Msg::Move(tok) => {
            match apply_token(&mut app.cube, &tok) {
                Ok(()) => app.status = format!("Did {tok}"),
                Err(e)  => app.status = e,
            }
        }

        Msg::Noop => {}
        _ => {}
    }

    Command::none()
}
===== src/app/mod.rs =====
pub mod view;
pub mod update;
pub mod support;

use iced::{Application, Command, Element, Theme, Settings};
use crate::cube::Cube;

pub fn run() -> iced::Result {
    App::run(Settings::default())
}

/* ---------------- Messages ----------------
   Keep both “seed” naming schemes so update/view stay in sync
   even if one side still emits the old variants.
*/
#[derive(Debug, Clone)]
pub enum Msg {
    // camera params
    LeftRzChanged(f32), LeftRxChanged(f32), LeftRyChanged(f32),
    RightRzChanged(f32), RightRxChanged(f32), RightRyChanged(f32),
    SizeChanged(f32),

    // camera helpers
    PresetLeft,
    PresetRight,
    ResetCameras,
    ToggleSnap90(bool),

    // algorithm panel
    AlgChanged(String),
    ApplyAlg,
    ResetCube,

    // seed / scramble panel
    SeedChanged(String),

    // New names (used by your UI now)
    ApplySeed,
    Scramble,
    Reset,

    // Legacy names (still referenced by some code paths)
    SeedGenerate,
    SeedScramble,
    SeedClear,
    ToggleOpposite(bool),

    // individual move buttons
    Move(String),

    Noop,
}
#[derive(Debug, Clone, Copy)]
pub struct ViewUI { pub rz: f32, pub rx: f32, pub ry: f32 }

#[derive(Debug, Clone, Copy)]
pub struct Params {
    pub size: f32,
    pub left: ViewUI,
    pub right: ViewUI,
}
impl Default for Params {
    fn default() -> Self {
        Self {
            // Smaller default cube size
            size: 22.0,
            // Start both cameras at (0,0,0)
            left:  ViewUI { rz: 0.0, rx: 0.0, ry: 0.0 },
            right: ViewUI { rz: 90.0, rx: 180.0, ry: 0.0 },
        }
    }
}
#[derive(Default)]
pub struct App {
    pub cube: Cube,
    pub alg_input: String,
    pub seed_input: String,
    pub status: String,
    pub params: Params,
    pub snap90: bool,

    pub link_opposite: bool,

}

impl Application for App {
    type Executor = iced::executor::Default;
    type Flags = ();
    type Message = Msg;
    type Theme = Theme;

    fn new(_flags: ()) -> (Self, Command<Msg>) {
        (Self::default(), Command::none())
    }

    fn title(&self) -> String {
        "2×2 Pocket Cube — Isometric 3D".into()
    }

    fn update(&mut self, msg: Msg) -> Command<Msg> {
        update::update(self, msg)
    }

    fn view(&self) -> Element<Msg> {
        view::view(self)
    }
}
===== src/app/view.rs =====
use iced::{
    Alignment, Element, Length,
    widget::{column, row, text, container, Space, Canvas, slider, checkbox},
};

use super::{App, Msg};
use crate::render::{CubeCanvas, ViewParams, RotZ, RotX, RotY};
use crate::ui::{
    build_angle_block,
    build_presets_row,
    build_seed_panel,
    build_algorithm_panel,
};
use crate::ui::moves::build_moves_scroller;

pub fn view(app: &App) -> Element<Msg> {
    // Build ViewParams for the renderer. Origins are auto-laid out in render code when NaN.
    let left  = ViewParams {
        rz: RotZ(app.params.left.rz),
        rx: RotX(app.params.left.rx),
        ry: RotY(app.params.left.ry),
        origin: (f32::NAN, f32::NAN),
        size: app.params.size,
    };
    let right = ViewParams {
        rz: RotZ(app.params.right.rz),
        rx: RotX(app.params.right.rx),
        ry: RotY(app.params.right.ry),
        origin: (f32::NAN, f32::NAN),
        size: app.params.size,
    };

    // ── Fixed canvas area so controls never get squeezed ─────────────
    const CANVAS_H: f32 = 320.0; // stable space for both cubes
    let canvas_raw: Element<()> = Canvas::new(CubeCanvas { cube: &app.cube, left, right })
        .width(Length::Fill)
        .height(Length::Fixed(CANVAS_H))
        .into();

    // Give the compiler an explicit type to avoid inference errors (E0283).
    let canvas_el: Element<Msg> = container(canvas_raw.map(|_| Msg::Noop))
        .width(Length::Fill)
        .center_x()
        .into();

    // ── Size slider (16..=40) ───────────────────────────────────────
    let size_row = row![
        text("Size"),
        Space::with_width(8),
        slider(16.0..=40.0, app.params.size, Msg::SizeChanged)
            .step(1.0)
            .width(Length::Fill),
        Space::with_width(12),
        text(format!("{:.0}px", app.params.size)),
    ]
        .spacing(8)
        .align_items(Alignment::Center)
        .width(Length::Fill);

    // ── Angle blocks ─────────────────────────────────────────────────
    let angles_row = row![
        build_angle_block(
            "Left view",
            app.params.left.rz, app.params.left.rx, app.params.left.ry,
            Msg::LeftRzChanged, Msg::LeftRxChanged, Msg::LeftRyChanged
        ),
        Space::with_width(16),
        build_angle_block(
            "Right view",
            app.params.right.rz, app.params.right.rx, app.params.right.ry,
            Msg::RightRzChanged, Msg::RightRxChanged, Msg::RightRyChanged
        ),
    ]
        .spacing(12)
        .width(Length::Fill);

    // ── Presets + “Opposite right” toggle ────────────────────────────
    let presets = build_presets_row(app.snap90);
    let presets_row = row![
        presets,
        Space::with_width(12),
        checkbox("Opposite right", app.link_opposite)
            .on_toggle(Msg::ToggleOpposite),
    ]
        .spacing(12)
        .align_items(Alignment::Center)
        .width(Length::Fill);

    // ── Moves (scrollable for small screens) ─────────────────────────
    let moves_scroller = build_moves_scroller();

    // ── Seed / Algorithm panels ──────────────────────────────────────
    let seed_panel = build_seed_panel(&app.seed_input);
    let alg_panel  = build_algorithm_panel(&app.alg_input);

    // ── Info + status line ───────────────────────────────────────────
    let info = text(format!(
        "Left (Rz,Rx,Ry)=({:.0}°, {:.0}°, {:.0}°)   Right (Rz,Rx,Ry)=({:.0}°, {:.0}°, {:.0}°)   Size={:.0}px",
        app.params.left.rz,  app.params.left.rx,  app.params.left.ry,
        app.params.right.rz, app.params.right.rx, app.params.right.ry,
        app.params.size
    ));

    let status: Element<Msg> = if app.status.is_empty() {
        Space::with_height(0).into()
    } else {
        container(text(&app.status))
            .width(Length::Fill)
            .padding([0, 2, 2, 2])
            .into()
    };

    // ── Title (smaller, centered) ────────────────────────────────────
    let title: Element<Msg> = container(text("2×2 Pocket Cube — Isometric 3D").size(24))
        .width(Length::Fill)
        .center_x()
        .into();

    // ── Layout ───────────────────────────────────────────────────────
    column![
        title,
        canvas_el,
        Space::with_height(8),
        size_row,
        container(
            column![
                angles_row,
                presets_row,
                moves_scroller,
                row![seed_panel, Space::with_width(16), alg_panel].spacing(16),
                info,
                status,
            ]
            .spacing(10)
            .width(Length::Fill)
        )
        .padding(10)
        .width(Length::Fill),
    ]
        .spacing(12)
        .width(Length::Fill)
        .into()
}
===== src/cube/mod.rs =====
// src/cube/mod.rs

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FaceId { U, D, F, B, L, R }

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Col { W, Y, G, B, O, R }

pub type Face = [[Col; 2]; 2];

#[derive(Debug, Clone)]
pub struct Cube {
    faces: [Face; 6], // order: U, D, F, B, L, R
}

impl Default for Cube {
    fn default() -> Self {
        use Col::*;
        // Standard color scheme:
        // U=White, D=Yellow, F=Green, B=Blue, L=Orange, R=Red
        let u = [[W, W],[W, W]];
        let d = [[Y, Y],[Y, Y]];
        let f = [[G, G],[G, G]];
        let b = [[B, B],[B, B]];
        let l = [[O, O],[O, O]];
        let r = [[R, R],[R, R]];
        Self { faces: [u, d, f, b, l, r] }
    }
}

// --------- getters used by renderer ---------

impl Cube {
    #[inline] pub fn face(&self, id: FaceId) -> &Face {
        &self.faces[id as usize]
    }
}

// --------- small helpers ---------

#[inline]
fn rot_face_cw(f: &mut Face) {
    // [[a,b],[c,d]] -> CW -> [[c,a],[d,b]]
    let a = f[0][0]; let b = f[0][1];
    let c = f[1][0]; let d = f[1][1];
    f[0][0] = c; f[0][1] = a;
    f[1][0] = d; f[1][1] = b;
}

#[inline]
fn rot_face_ccw(f: &mut Face) {
    // [[a,b],[c,d]] -> CCW -> [[b,d],[a,c]]
    let a = f[0][0]; let b = f[0][1];
    let c = f[1][0]; let d = f[1][1];
    f[0][0] = b; f[0][1] = d;
    f[1][0] = a; f[1][1] = c;
}

#[inline]
fn rot_face_180(f: &mut Face) {
    // [[a,b],[c,d]] -> 180 -> [[d,c],[b,a]]
    let a = f[0][0]; let b = f[0][1];
    let c = f[1][0]; let d = f[1][1];
    f[0][0] = d; f[0][1] = c;
    f[1][0] = b; f[1][1] = a;
}

// --------- move engine (2x2) ---------
//
// Face indexing:
//   faces[U=0], faces[D=1], faces[F=2], faces[B=3], faces[L=4], faces[R=5]
//
// Sticker indexing: [row][col] with row 0 = top, col 0 = left,
// in the orientation of the face when you look straight at it.
//

impl Cube {
    // U, U', U2
    pub fn mv_u(&mut self)          { self.u_cw(); }
    pub fn mv_u_prime(&mut self)    { self.u_ccw(); }
    pub fn mv_u2(&mut self)         { self.u_180(); }

    // D
    pub fn mv_d(&mut self)          { self.d_cw(); }
    pub fn mv_d_prime(&mut self)    { self.d_ccw(); }
    pub fn mv_d2(&mut self)         { self.d_180(); }

    // R
    pub fn mv_r(&mut self)          { self.r_cw(); }
    pub fn mv_r_prime(&mut self)    { self.r_ccw(); }
    pub fn mv_r2(&mut self)         { self.r_180(); }

    // L
    pub fn mv_l(&mut self)          { self.l_cw(); }
    pub fn mv_l_prime(&mut self)    { self.l_ccw(); }
    pub fn mv_l2(&mut self)         { self.l_180(); }

    // F
    pub fn mv_f(&mut self)          { self.f_cw(); }
    pub fn mv_f_prime(&mut self)    { self.f_ccw(); }
    pub fn mv_f2(&mut self)         { self.f_180(); }

    // B
    pub fn mv_b(&mut self)          { self.b_cw(); }
    pub fn mv_b_prime(&mut self)    { self.b_ccw(); }
    pub fn mv_b2(&mut self)         { self.b_180(); }
}

// Each move is face rotation + a 4-way cycle of edge rows/cols.
// The cycles below are chosen to work with the renderer’s face orientations.
//
// If anything looks mirrored in your specific render, swap the order marked
// with comments (“// may need reverse”); but these should match the earlier
// U/F/R identity and the D/L/B flipped view.

impl Cube {

    fn u_cw(&mut self) {
        const U: usize = FaceId::U as usize;
        const F: usize = FaceId::F as usize;
        const R: usize = FaceId::R as usize;
        const B: usize = FaceId::B as usize;
        const L: usize = FaceId::L as usize;

        rot_face_cw(&mut self.faces[U]);

        // snapshot rows
        let f0 = self.faces[F][0];
        let r0 = self.faces[R][0];
        let b0 = self.faces[B][0];
        let l0 = self.faces[L][0];

        // cycle F -> R -> B -> L -> F (top rows)
        self.faces[R][0] = f0;
        self.faces[B][0] = r0;
        self.faces[L][0] = b0;
        self.faces[F][0] = l0;
    }

    fn d_cw(&mut self) {
        const D: usize = FaceId::D as usize;
        const F: usize = FaceId::F as usize;
        const R: usize = FaceId::R as usize;
        const B: usize = FaceId::B as usize;
        const L: usize = FaceId::L as usize;

        rot_face_cw(&mut self.faces[D]);

        // snapshot rows
        let f1 = self.faces[F][1];
        let r1 = self.faces[R][1];
        let b1 = self.faces[B][1];
        let l1 = self.faces[L][1];

        // cycle F(bottom) -> L(bottom) -> B(bottom) -> R(bottom) -> F(bottom)
        self.faces[L][1] = f1;
        self.faces[B][1] = l1;
        self.faces[R][1] = b1;
        self.faces[F][1] = r1;
    }

    fn r_cw(&mut self) {
        const U: usize = FaceId::U as usize;
        const D: usize = FaceId::D as usize;
        const F: usize = FaceId::F as usize;
        const B: usize = FaceId::B as usize;
        const R: usize = FaceId::R as usize;

        rot_face_cw(&mut self.faces[R]);

        // snapshot columns (right col of U/F/D, left col of B, note reversals)
        let u_col = [self.faces[U][0][1], self.faces[U][1][1]];
        let f_col = [self.faces[F][0][1], self.faces[F][1][1]];
        let d_col = [self.faces[D][0][1], self.faces[D][1][1]];
        let b_col = [self.faces[B][0][0], self.faces[B][1][0]]; // B left

        // U right -> F right
        self.faces[F][0][1] = u_col[0];
        self.faces[F][1][1] = u_col[1];

        // F right -> D right
        self.faces[D][0][1] = f_col[0];
        self.faces[D][1][1] = f_col[1];

        // D right -> B left (reversed)
        self.faces[B][0][0] = d_col[1];
        self.faces[B][1][0] = d_col[0];

        // B left (reversed) -> U right
        self.faces[U][0][1] = b_col[1];
        self.faces[U][1][1] = b_col[0];
    }

    fn l_cw(&mut self) {
        const U: usize = FaceId::U as usize;
        const D: usize = FaceId::D as usize;
        const F: usize = FaceId::F as usize;
        const B: usize = FaceId::B as usize;
        const L: usize = FaceId::L as usize;

        rot_face_cw(&mut self.faces[L]);

        // snapshot columns (left col of U/F/D, right col of B)
        let u_col = [self.faces[U][0][0], self.faces[U][1][0]];
        let f_col = [self.faces[F][0][0], self.faces[F][1][0]];
        let d_col = [self.faces[D][0][0], self.faces[D][1][0]];
        let b_col = [self.faces[B][0][1], self.faces[B][1][1]]; // B right

        // U left -> B right (reversed)
        self.faces[B][0][1] = u_col[1];
        self.faces[B][1][1] = u_col[0];

        // B right (reversed) -> D left
        self.faces[D][0][0] = b_col[1];
        self.faces[D][1][0] = b_col[0];

        // D left -> F left
        self.faces[F][0][0] = d_col[0];
        self.faces[F][1][0] = d_col[1];

        // F left -> U left
        self.faces[U][0][0] = f_col[0];
        self.faces[U][1][0] = f_col[1];
    }

    fn f_cw(&mut self) {
        const U: usize = FaceId::U as usize;
        const D: usize = FaceId::D as usize;
        const F: usize = FaceId::F as usize;
        const L: usize = FaceId::L as usize;
        const R: usize = FaceId::R as usize;

        rot_face_cw(&mut self.faces[F]);

        // snapshot strips
        let u_bot = [self.faces[U][1][0], self.faces[U][1][1]]; // U bottom
        let r_lft = [self.faces[R][0][0], self.faces[R][1][0]]; // R left (top->bottom)
        let d_top = [self.faces[D][0][0], self.faces[D][0][1]]; // D top
        let l_rgt = [self.faces[L][0][1], self.faces[L][1][1]]; // L right (top->bottom)

        // U bottom -> R left (reversed)
        self.faces[R][0][0] = u_bot[1];
        self.faces[R][1][0] = u_bot[0];

        // R left -> D top
        self.faces[D][0][0] = r_lft[0];
        self.faces[D][0][1] = r_lft[1];

        // D top -> L right (reversed)
        self.faces[L][0][1] = d_top[1];
        self.faces[L][1][1] = d_top[0];

        // L right -> U bottom
        self.faces[U][1][0] = l_rgt[0];
        self.faces[U][1][1] = l_rgt[1];
    }

    fn b_cw(&mut self) {
        const U: usize = FaceId::U as usize;
        const D: usize = FaceId::D as usize;
        const B: usize = FaceId::B as usize;
        const L: usize = FaceId::L as usize;
        const R: usize = FaceId::R as usize;

        rot_face_cw(&mut self.faces[FaceId::B as usize]);

        // snapshot strips
        let u_top = [self.faces[U][0][0], self.faces[U][0][1]]; // U top
        let l_lft = [self.faces[L][0][0], self.faces[L][1][0]]; // L left
        let d_bot = [self.faces[D][1][0], self.faces[D][1][1]]; // D bottom
        let r_rgt = [self.faces[R][0][1], self.faces[R][1][1]]; // R right

        // U top -> L left (reversed)
        self.faces[L][0][0] = u_top[1];
        self.faces[L][1][0] = u_top[0];

        // L left -> D bottom
        self.faces[D][1][0] = l_lft[0];
        self.faces[D][1][1] = l_lft[1];

        // D bottom -> R right (reversed)
        self.faces[R][0][1] = d_bot[1];
        self.faces[R][1][1] = d_bot[0];

        // R right -> U top
        self.faces[U][0][0] = r_rgt[0];
        self.faces[U][0][1] = r_rgt[1];
    }

}


impl Cube {
    // ── U helpers ──────────────────────────────────────────────────────────────
    #[inline] fn u_ccw(&mut self) { self.u_cw(); self.u_cw(); self.u_cw(); }
    #[inline] fn u_180(&mut self) { self.u_cw(); self.u_cw(); }

    // ── D helpers ──────────────────────────────────────────────────────────────
    #[inline] fn d_ccw(&mut self) { self.d_cw(); self.d_cw(); self.d_cw(); }
    #[inline] fn d_180(&mut self) { self.d_cw(); self.d_cw(); }

    // ── R helpers ──────────────────────────────────────────────────────────────
    #[inline] fn r_ccw(&mut self) { self.r_cw(); self.r_cw(); self.r_cw(); }
    #[inline] fn r_180(&mut self) { self.r_cw(); self.r_cw(); }

    // ── L helpers ──────────────────────────────────────────────────────────────
    #[inline] fn l_ccw(&mut self) { self.l_cw(); self.l_cw(); self.l_cw(); }
    #[inline] fn l_180(&mut self) { self.l_cw(); self.l_cw(); }

    // ── F helpers ──────────────────────────────────────────────────────────────
    #[inline] fn f_ccw(&mut self) { self.f_cw(); self.f_cw(); self.f_cw(); }
    #[inline] fn f_180(&mut self) { self.f_cw(); self.f_cw(); }

    // ── B helpers ──────────────────────────────────────────────────────────────
    #[inline] fn b_ccw(&mut self) { self.b_cw(); self.b_cw(); self.b_cw(); }
    #[inline] fn b_180(&mut self) { self.b_cw(); self.b_cw(); }
}
===== src/logic/scramble.rs =====
use rand::seq::SliceRandom;
use rand::thread_rng;
use rand::rngs::StdRng;
use rand::SeedableRng;

const MOVES: &[&str] = &[
    "U","U'","U2","D","D'","D2","R","R'","R2","L","L'","L2","F","F'","F2","B","B'","B2",
];

pub fn random_scramble(len: usize) -> String {
    let mut rng = thread_rng();
    (0..len).map(|_| *MOVES.choose(&mut rng).unwrap()).collect::<Vec<_>>().join(" ")
}

pub fn scramble_with_seed(len: usize, seed: u64) -> String {
    let mut rng = StdRng::seed_from_u64(seed);
    (0..len).map(|_| *MOVES.choose(&mut rng).unwrap()).collect::<Vec<_>>().join(" ")
}
===== src/logic/mod.rs =====
pub mod scramble;

===== src/render/types.rs =====
#[derive(Copy, Clone, Debug)]
pub struct RotZ(pub f32);
#[derive(Copy, Clone, Debug)]
pub struct RotX(pub f32);
#[derive(Copy, Clone, Debug)]
pub struct RotY(pub f32);

#[derive(Copy, Clone, Debug)]
pub struct ViewParams {
    pub rz: RotZ,
    pub rx: RotX,
    pub ry: RotY,
    pub origin: (f32, f32),
    pub size: f32,
}
===== src/render/layout.rs =====
use iced::Rectangle;

use super::types::ViewParams;
use super::geom::{project, rotate_pt_all};

/// 8 cube corners in object space (2×2×2 cube)
#[inline]
fn cube_corners() -> [(f32,f32,f32); 8] {
    [
        (0.0,0.0,0.0), (2.0,0.0,0.0), (0.0,2.0,0.0), (2.0,2.0,0.0),
        (0.0,0.0,2.0), (2.0,0.0,2.0), (0.0,2.0,2.0), (2.0,2.0,2.0),
    ]
}

fn min_projected_y(vp: &ViewParams) -> f32 {
    cube_corners()
        .map(|p| rotate_pt_all(p, vp.rz, vp.ry, vp.rx))
        .map(|(x,y,z)| project(x, y, z, vp.size, vp.origin).1)
        .into_iter()
        .fold(f32::INFINITY, f32::min)
}

fn max_projected_y(vp: &ViewParams) -> f32 {
    cube_corners()
        .map(|p| rotate_pt_all(p, vp.rz, vp.ry, vp.rx))
        .map(|(x,y,z)| project(x, y, z, vp.size, vp.origin).1)
        .into_iter()
        .fold(f32::NEG_INFINITY, f32::max)
}

/// Initial horizontal placement + vertical center line.
pub fn layout_origins(bounds: Rectangle, size: f32) -> ((f32,f32),(f32,f32)) {
    let mid_x    = bounds.x + bounds.width * 0.5;
    let center_y = bounds.y + bounds.height * 0.48; // near true vertical center

    // Horizontal spacing that scales with width/size but stays reasonable
    let min_gap = size * 2.6;
    let max_gap = bounds.width * 0.60;
    let gap = ((bounds.width * 0.30) + size * 1.0).clamp(min_gap, max_gap);

    ((mid_x - gap * 0.5, center_y), (mid_x + gap * 0.5, center_y))
}

/// Shift both origins vertically so the pair stays centered and within margins.
pub fn fit_vertically(bounds: Rectangle, left: &mut ViewParams, right: &mut ViewParams) {
    // Combined vertical bounding box (screen Y) for both cubes
    let (min_l, max_l) = (min_projected_y(left),  max_projected_y(left));
    let (min_r, max_r) = (min_projected_y(right), max_projected_y(right));
    let min_all = min_l.min(min_r);
    let max_all = max_l.max(max_r);
    let center_all = 0.5 * (min_all + max_all);

    // Target vertical center (slightly above exact middle so UI has air)
    let desired_center = bounds.y + bounds.height * 0.48;

    // Shift needed to center
    let mut dy = desired_center - center_all;

    // Keep inside top/bottom margins
    let top_margin    = bounds.y + 8.0;
    let bottom_margin = bounds.y + bounds.height - 8.0;
    dy = dy.clamp(top_margin - min_all, bottom_margin - max_all);

    if dy.abs() > 0.01 {
        left.origin.1  += dy;
        right.origin.1 += dy;
    }
}
===== src/render/geom.rs =====
use iced::Point;

use crate::cube::FaceId;
use super::types::{RotZ, RotX, RotY};

/// classic isometric projection
#[inline]
pub fn project(x: f32, y: f32, z: f32, size: f32, origin: (f32, f32)) -> (f32, f32) {
    let ex = (0.8660254, -0.5);
    let ey = (-0.8660254, -0.5);
    let ez = (0.0,       -1.0);
    let px = origin.0 + size * (x * ex.0 + y * ey.0 + z * ez.0);
    let py = origin.1 + size * (x * ex.1 + y * ey.1 + z * ez.1);
    (px, py)
}

// rotate about cube center (1,1,1)
const CEN: (f32, f32, f32) = (1.0, 1.0, 1.0);

#[inline]
fn rot_z_point(p: (f32,f32,f32), deg: f32) -> (f32,f32,f32) {
    let (x,y,z) = p; let (x0,y0,z0) = (x-CEN.0, y-CEN.1, z-CEN.2);
    let r = deg.to_radians(); let (c,s) = (r.cos(), r.sin());
    (c*x0 - s*y0 + CEN.0, s*x0 + c*y0 + CEN.1, z0 + CEN.2)
}
#[inline]
fn rot_y_point(p: (f32,f32,f32), deg: f32) -> (f32,f32,f32) {
    let (x,y,z) = p; let (x0,y0,z0) = (x-CEN.0, y-CEN.1, z-CEN.2);
    let r = deg.to_radians(); let (c,s) = (r.cos(), r.sin());
    (c*x0 + s*z0 + CEN.0, y0 + CEN.1, -s*x0 + c*z0 + CEN.2)
}
#[inline]
fn rot_x_point(p: (f32,f32,f32), deg: f32) -> (f32,f32,f32) {
    let (x,y,z) = p; let (x0,y0,z0) = (x-CEN.0, y-CEN.1, z-CEN.2);
    let r = deg.to_radians(); let (c,s) = (r.cos(), r.sin());
    (x0 + CEN.0, c*y0 - s*z0 + CEN.1, s*y0 + c*z0 + CEN.2)
}

#[inline]
pub fn rotate_pt_all(p: (f32,f32,f32), rz: RotZ, ry: RotY, rx: RotX) -> (f32,f32,f32) {
    let pz = rot_z_point(p, rz.0);
    let py = rot_y_point(pz, ry.0);
    rot_x_point(py, rx.0)
}

// outer polygon of each face in CCW order w.r.t. OUTWARD normal
pub fn face_outer(face: FaceId) -> [(f32,f32,f32);4] {
    match face {
        // +Z (Up): u=+X, v=+Y
        FaceId::U => [(0.0,0.0,2.0),(2.0,0.0,2.0),(2.0,2.0,2.0),(0.0,2.0,2.0)],
        // -Z (Down): u=+X, v=-Y
        FaceId::D => [(0.0,2.0,0.0),(2.0,2.0,0.0),(2.0,0.0,0.0),(0.0,0.0,0.0)],
        // -Y (Front): u=+X, v=+Z, plane y=0
        FaceId::F => [(0.0,0.0,0.0),(2.0,0.0,0.0),(2.0,0.0,2.0),(0.0,0.0,2.0)],
        // +Y (Back): u=-X, v=+Z, plane y=2
        FaceId::B => [(2.0,2.0,0.0),(0.0,2.0,0.0),(0.0,2.0,2.0),(2.0,2.0,2.0)],
        // -X (Left): u=+Y, v=-Z, plane x=0
        FaceId::L => [(0.0,0.0,2.0),(0.0,2.0,2.0),(0.0,2.0,0.0),(0.0,0.0,0.0)],
        // +X (Right): u=+Y, v=+Z, plane x=2
        FaceId::R => [(2.0,0.0,0.0),(2.0,2.0,0.0),(2.0,2.0,2.0),(2.0,0.0,2.0)],
    }
}

// per-cell raw quad (no inset)
pub fn face_cell_raw(face: FaceId, r: usize, c: usize) -> [(f32,f32,f32);4] {
    let r = r as f32;
    let c = c as f32;
    let p = |x: f32, y: f32, z: f32| (x, y, z);

    match face {
        FaceId::U => [ p(c, r, 2.0), p(c+1.0, r, 2.0), p(c+1.0, r+1.0, 2.0), p(c, r+1.0, 2.0) ],
        FaceId::D => [ p(c, 2.0-r, 0.0), p(c+1.0, 2.0-r, 0.0), p(c+1.0, 2.0-(r+1.0), 0.0), p(c, 2.0-(r+1.0), 0.0) ],
        FaceId::F => { let z0=2.0-r; let z1=2.0-(r+1.0);
            [ p(c,0.0,z0), p(c+1.0,0.0,z0), p(c+1.0,0.0,z1), p(c,0.0,z1) ] }
        FaceId::B => { let z0=2.0-r; let z1=2.0-(r+1.0);
            [ p(2.0-c,2.0,z0), p(2.0-(c+1.0),2.0,z0), p(2.0-(c+1.0),2.0,z1), p(2.0-c,2.0,z1) ] }
        FaceId::L => { let z0=2.0-r; let z1=2.0-(r+1.0);
            [ p(0.0,2.0-c,z0), p(0.0,2.0-(c+1.0),z0), p(0.0,2.0-(c+1.0),z1), p(0.0,2.0-c,z1) ] }
        FaceId::R => { let z0=2.0-r; let z1=2.0-(r+1.0);
            [ p(2.0,c,z0), p(2.0,c+1.0,z0), p(2.0,c+1.0,z1), p(2.0,c,z1) ] }
    }
}

/// inset a 2D quad toward its centroid by fraction k (0..1)
pub fn inset_polygon(pts: &[(f32,f32);4], k: f32) -> [(f32,f32);4] {
    let cx = (pts[0].0 + pts[1].0 + pts[2].0 + pts[3].0) * 0.25;
    let cy = (pts[0].1 + pts[1].1 + pts[2].1 + pts[3].1) * 0.25;
    [
        (cx + (pts[0].0 - cx) * (1.0 - k), cy + (pts[0].1 - cy) * (1.0 - k)),
        (cx + (pts[1].0 - cx) * (1.0 - k), cy + (pts[1].1 - cy) * (1.0 - k)),
        (cx + (pts[2].0 - cx) * (1.0 - k), cy + (pts[2].1 - cy) * (1.0 - k)),
        (cx + (pts[3].0 - cx) * (1.0 - k), cy + (pts[3].1 - cy) * (1.0 - k)),
    ]
}

/// simple back-face test using projected signed area
pub fn face_visible(face: FaceId, rz: RotZ, rx: RotX, ry: RotY) -> bool {
    let q3 = face_outer(face).map(|p| rotate_pt_all(p, rz, ry, rx));
    let pts = q3.map(|(x,y,z)| project(x, y, z, 1.0, (0.0, 0.0)));

    let mut a = 0.0f32;
    for i in 0..4 {
        let j = (i + 1) & 3;
        a += pts[i].0 * pts[j].1 - pts[j].0 * pts[i].1;
    }
    a < 0.0
}

pub fn face_depth(face: FaceId, rz: RotZ, rx: RotX, ry: RotY) -> f32 {
    let c0 = match face {
        FaceId::U => (1.0, 1.0, 2.0),
        FaceId::D => (1.0, 1.0, 0.0),
        FaceId::F => (1.0, 0.0, 1.0),
        FaceId::B => (1.0, 2.0, 1.0),
        FaceId::L => (0.0, 1.0, 1.0),
        FaceId::R => (2.0, 1.0, 1.0),
    };
    // correct order: (rz, ry, rx)
    let c = rotate_pt_all(c0, rz, ry, rx);
    let (_px, py) = project(c.0, c.1, c.2, 1.0, (0.0, 0.0));
    -py
}

/// 8 cube corners in object space (2x2x2 cube)
#[inline]
pub fn cube_corners() -> [(f32,f32,f32); 8] {
    [
        (0.0,0.0,0.0), (2.0,0.0,0.0), (0.0,2.0,0.0), (2.0,2.0,0.0),
        (0.0,0.0,2.0), (2.0,0.0,2.0), (0.0,2.0,2.0), (2.0,2.0,2.0),
    ]
}
===== src/render/mod.rs =====
pub mod types;
pub mod geom;
pub mod face;
pub mod layout;
pub mod canvas;

pub use types::{RotZ, RotX, RotY, ViewParams};
pub use canvas::CubeCanvas;
===== src/render/face.rs =====
use iced::{Color};
use iced::widget::canvas::{self, Frame};

use crate::cube::{Col, Face, FaceId};
use super::types::{RotZ, RotX, RotY};
use super::geom::{project, face_outer, face_cell_raw, inset_polygon, face_visible, rotate_pt_all};

fn base_color(c: Col) -> Color {
    match c {
        Col::W => Color::from_rgb(1.0, 1.0, 1.0),
        Col::Y => Color::from_rgb(1.0, 0.90, 0.00),
        Col::R => Color::from_rgb(0.90, 0.00, 0.00),
        Col::O => Color::from_rgb(1.00, 0.50, 0.00),
        Col::B => Color::from_rgb(0.00, 0.35, 0.90),
        Col::G => Color::from_rgb(0.00, 0.60, 0.20),
    }
}

fn path_polygon(points: &[[f32; 2]]) -> canvas::Path {
    canvas::Path::new(|b| {
        if let Some(first) = points.first() {
            b.move_to(iced::Point::new(first[0], first[1]));
            for p in &points[1..] { b.line_to(iced::Point::new(p[0], p[1])); }
            b.close();
        }
    })
}

pub fn draw_face(
    fr: &mut Frame,
    face: &Face,
    which: FaceId,
    origin: (f32,f32),
    size: f32,
    rz: RotZ,
    rx: RotX,
    ry: RotY,
) {
    if !face_visible(which, rz, rx, ry) { return; }

    // 1) plastic base
    let outer = face_outer(which).map(|p| rotate_pt_all(p, rz, ry, rx));
    let outer_xy = outer.map(|(x,y,z)| project(x,y,z, size, origin));
    let outer_path = path_polygon(&[
        [outer_xy[0].0, outer_xy[0].1],
        [outer_xy[1].0, outer_xy[1].1],
        [outer_xy[2].0, outer_xy[2].1],
        [outer_xy[3].0, outer_xy[3].1],
    ]);

    let plastic_w = (size * 0.070).clamp(0.9, 2.4);
    let seam_w    = (size * 0.030).clamp(0.4, 1.2);
    let inset_k   = (0.09 + (size - 24.0) * 0.002).clamp(0.09, 0.14);

    fr.fill(&outer_path, Color::from_rgb(0.05,0.05,0.05));
    fr.stroke(&outer_path, canvas::Stroke {
        width: plastic_w,
        style: canvas::stroke::Style::Solid(Color::from_rgb(0.03,0.03,0.03)),
        ..Default::default()
    });

    // 2) stickers
    for r in 0..2 {
        for c in 0..2 {
            let q3 = face_cell_raw(which, r, c).map(|p| rotate_pt_all(p, rz, ry, rx));
            let pts = q3.map(|(x,y,z)| project(x,y,z, size, origin));

            let raw2d = [
                (pts[0].0, pts[0].1),
                (pts[1].0, pts[1].1),
                (pts[2].0, pts[2].1),
                (pts[3].0, pts[3].1),
            ];
            let inset = inset_polygon(&raw2d, inset_k);

            let poly = path_polygon(&[
                [inset[0].0, inset[0].1],
                [inset[1].0, inset[1].1],
                [inset[2].0, inset[2].1],
                [inset[3].0, inset[3].1],
            ]);

            fr.fill(&poly, base_color(face[r][c]));
            fr.stroke(&poly, canvas::Stroke {
                width: seam_w,
                style: canvas::stroke::Style::Solid(Color::from_rgb(0.04,0.04,0.04)),
                ..Default::default()
            });
        }
    }
}
===== src/render/canvas.rs =====
use iced::widget::canvas::{self, Frame, Program};
use iced::{Theme, Rectangle};

use super::types::ViewParams;
use super::face::{draw_face};
use super::layout::{layout_origins, fit_vertically};
use crate::cube::{Cube, FaceId};
use crate::render::geom::face_depth;

pub struct CubeCanvas<'a> {
    pub cube: &'a Cube,
    pub left: ViewParams,
    pub right: ViewParams,
}
impl<'a> Program<()> for CubeCanvas<'a> {
    type State = ();

    fn draw(
        &self,
        _state: &Self::State,
        renderer: &iced::Renderer,
        _theme: &Theme,
        bounds: iced::Rectangle,
        _cursor: iced::mouse::Cursor,
    ) -> Vec<canvas::Geometry> {
        let mut frame = Frame::new(renderer, bounds.size());

        // 1) Start with your incoming params
        let mut left  = self.left;
        let mut right = self.right;

        // 2) If origins are NaN (our signal to auto-place), give them a first pass
        if left.origin.0.is_nan() || right.origin.0.is_nan() {
            let (ol, or) = layout_origins(bounds, left.size.min(right.size));
            if left.origin.0.is_nan()  { left.origin  = ol; }
            if right.origin.0.is_nan() { right.origin = or; }
        }

        // 3) Nudge both views so the pair is vertically centered *and*
        //    still respects top/bottom margins for the current size.
        fit_vertically(bounds, &mut left, &mut right);

        // 4) Depth-sorted render with the adjusted origins
        let mut render = |vp: ViewParams| {
            let ViewParams { rz, rx, ry, origin, size } = vp;

            let mut faces = [FaceId::U, FaceId::R, FaceId::F, FaceId::D, FaceId::L, FaceId::B];
            faces.sort_by(|a, b| face_depth(*a, rz, rx, ry)
                .partial_cmp(&face_depth(*b, rz, rx, ry)).unwrap());

            for f in faces {
                draw_face(&mut frame, self.cube.face(f), f, origin, size, rz, rx, ry);
            }
        };

        render(left);
        render(right);

        vec![frame.into_geometry()]
    }
}
===== src/main.rs =====
mod render;
mod ui;
mod logic;
pub mod cube;
mod app;

use iced::widget::{
    column, row, text, slider, text_input, button, container, Space, Canvas, checkbox,
};
use iced::{Alignment, Length, Element, Application, Settings, Command, Theme};

use render::{CubeCanvas, ViewParams, RotZ, RotX, RotY};

use rand::seq::SliceRandom;
use rand::thread_rng;
use crate::app::{App, Msg};

fn main() -> iced::Result {
    App::run(Settings::default())
}



